full$var$feature_types
source("C:/Users/mz24b548/Desktop/scLinear_branch/Reproduce_training.R")
source("~/GitRepos_local/scLinear_R/R/sclinear.R")
evaluation <- evaluate_predictor(pretrained,gex_test,adt_test,normalize_gex = FALSE, normalize_adt = FALSE)
ranking <- length(evaluation$pearson)+1-rank(evaluation$pearson)
evaluation_trainset <- evaluate_predictor(pretrained,gex_train,adt_train,normalize_gex = FALSE, normalize_adt = FALSE)
evaluation_trainset
ranking
sort(ranking)
ranking <- sort(length(evaluation$pearson)+1-rank(evaluation$pearson))
ranking
cor(gex_test['CD72',],adt_test['CD72',])
cor(gex_test['CD72',],adt_test['CD72',], method = 'pearson')
cor(gex_test['CD19',],adt_test['CD19',], method = 'pearson')
evaluation$pearson
sort(evaluation$pearson)
fi <- feature_importance(pretrained,gex_test,normalize_gex = FALSE)
source("~/GitRepos_local/scLinear_R/R/sclinear.R")
fi <- feature_importance(pretrained,gex_test,normalize_gex = FALSE)
source("~/GitRepos_local/scLinear_R/R/sclinear.R")
fi <- feature_importance(pretrained,gex_test,normalize_gex = FALSE)
cell_projection
name(cell_projection)
print('a')
parallel::stopCluster()
source("~/GitRepos_local/scLinear_R/R/sclinear.R")
source("~/GitRepos_local/scLinear_R/R/sclinear.R")
source("~/GitRepos_local/scLinear_R/R/sclinear.R")
source("~/GitRepos_local/scLinear_R/R/sclinear.R")
fi <- feature_importance(pretrained,gex_test,normalize_gex = FALSE)
warnings()
source("~/GitRepos_local/scLinear_R/R/sclinear.R")
fi <- feature_importance(pretrained,gex_test,normalize_gex = FALSE)
WJV <- abind::abind(pbapply::pblapply(cl=cl,WJ,function(WJ){
tryCatch({
return(WJ %*% v_t)
}, error = function(e) {
message("Error calculating matrix product WJV", ": ", e$message)
return(NULL)  # Return NULL if there's an error
})
return(WJ %*% v_t)
}), along = 3)
?pbapply
reticulate::use_condaenv("C:/Users/mz24b548/AppData/Local/miniconda3/envs/scLinearDependencies")
full <- anndata::read_h5ad('GSE194122_openproblems_neurips2021_cite_BMMC_processed.h5ad/GSE194122_openproblems_neurips2021_cite_BMMC_processed.h5ad')
traindat <- full[full$obs$is_train == 'train']
testdat <- full[full$obs$is_train == 'test']
gex_train <- traindat[,traindat$var$feature_types == 'GEX']$X
gex_train <- as(as.matrix(gex_train),'dgCMatrix')
adt_train <- traindat[,traindat$var$feature_types == 'ADT']$X
adt_train <- as(as.matrix(adt_train),'dgCMatrix')
gex_test <- testdat[,testdat$var$feature_types == 'GEX']$X
gex_test <- as(as.matrix(gex_test),'dgCMatrix')
adt_test <- testdat[,testdat$var$feature_types == 'ADT']$X
adt_test <- as(as.matrix(adt_test),'dgCMatrix')
# Size factor normalization already done but log1p not done
# CLR for ADT already done
gex_train <- Matrix::t(log1p(gex_train))
gex_test <- Matrix::t(log1p(gex_test))
adt_train <- Matrix::t(adt_train)
adt_test <- Matrix::t(adt_test)
pretrained <- readRDS('model_full_neurips')
source("~/GitRepos_local/scLinear_R/R/sclinear.R")
fi <- feature_importance(pretrained,gex_test,normalize_gex = FALSE)
fi <- feature_importance(pretrained,gex_test,normalize_gex = FALSE,n_cores = 6)
fi <- feature_importance(pretrained,gex_test,normalize_gex = FALSE,n_cores = 2)
parallel::stopCluster()
fi <- feature_importance(pretrained,gex_test,normalize_gex = FALSE,n_cores = 2)
parallel::stopCluster()
parallel::stopCluster()
parallel::stopCluster()
parallel::stopCluster()
?stopCluster
fi <- feature_importance(pretrained,gex_test,normalize_gex = FALSE,n_cores = 4)
reticulate::use_condaenv("C:/Users/mz24b548/AppData/Local/miniconda3/envs/scLinearDependencies")
full <- anndata::read_h5ad('GSE194122_openproblems_neurips2021_cite_BMMC_processed.h5ad/GSE194122_openproblems_neurips2021_cite_BMMC_processed.h5ad')
traindat <- full[full$obs$is_train == 'train']
testdat <- full[full$obs$is_train == 'test']
gex_train <- traindat[,traindat$var$feature_types == 'GEX']$X
gex_train <- as(as.matrix(gex_train),'dgCMatrix')
adt_train <- traindat[,traindat$var$feature_types == 'ADT']$X
adt_train <- as(as.matrix(adt_train),'dgCMatrix')
gex_test <- testdat[,testdat$var$feature_types == 'GEX']$X
gex_test <- as(as.matrix(gex_test),'dgCMatrix')
adt_test <- testdat[,testdat$var$feature_types == 'ADT']$X
adt_test <- as(as.matrix(adt_test),'dgCMatrix')
# Size factor normalization already done but log1p not done
# CLR for ADT already done
gex_train <- Matrix::t(log1p(gex_train))
gex_test <- Matrix::t(log1p(gex_test))
adt_train <- Matrix::t(adt_train)
adt_test <- Matrix::t(adt_test)
# predi <- fit_predictor(gex_train,adt_train,gex_test,normalize_gex = FALSE, normalize_adt =  FALSE)
pretrained <- readRDS('model_full_neurips')
fi <- feature_importance(pretrained,gex_test,normalize_gex = FALSE,n_cores = 1)
source("~/GitRepos_local/scLinear_R/R/sclinear.R")
fi <- feature_importance(pretrained,gex_test,normalize_gex = FALSE,n_cores = 1)
parallel::stopCluster()
fi <- feature_importance(pretrained,gex_test,normalize_gex = FALSE,n_cores = 3)
install.packages('deriv')
install.packages('Deriv')
zf <- function(x) (x-mean(x)) / sd(x)
jacf <- Deriv::Deriv(zf)
rm(zf)
zf <- function(x) {(x-mean(x)) / sd(x)}
jacf <- Deriv::Deriv(zf)
fz
zf
fi <- feature_importance(pretrained,gex_test,normalize_gex = FALSE,n_cores = 3)
View(Js)
saveRDS(Js,'jacobians')
saveRDS(gexp_projected,'jacobian_input')
rm(list=ls())
print('a')
Js <- readRDS('jacobians')
View(Js)
View(Js)
jacin <- readRDS('jacobian_input')
dim(jacin)
ele <- jacin[1]
ele
jacin
ele <- jacin[1,]
jaci
ele
Ele
length(ele)
non_constant <- (ele - m) %*% (ele-m)
ele <- jacin[1,]
N <- length(ele) #later ncol so only done once
sd <- sd(ele)
m <- mean(ele)
non_constant <- (ele - m) %*% (ele-m)
non_constant
non_constant <- (ele - m) %*% t(ele-m)
non_constant
sd^2
func2 <- function(x) c(sin(x), cos(x))
x <- (0:1)*2*pi
jacobian(func2, x)
func2 <- function(x) c(sin(x), cos(x))
x <- (0:1)*2*pi
numDeriv::jacobian(func2, x)
x
func2 <- function(x) c(sin(x), cos(x))
x <- (0:2)*2*pi
numDeriv::jacobian(func2, x)
func2 <- function(x) sin(x)
x <- (0:2)*2*pi
numDeriv::jacobian(func2, x)
source("~/GitRepos_local/scLinear_R/R/sclinear.R")
reticulate::use_condaenv("C:/Users/mz24b548/AppData/Local/miniconda3/envs/scLinearDependencies")
full <- anndata::read_h5ad('GSE194122_openproblems_neurips2021_cite_BMMC_processed.h5ad/GSE194122_openproblems_neurips2021_cite_BMMC_processed.h5ad')
traindat <- full[full$obs$is_train == 'train']
testdat <- full[full$obs$is_train == 'test']
gex_train <- traindat[,traindat$var$feature_types == 'GEX']$X
gex_train <- as(as.matrix(gex_train),'dgCMatrix')
adt_train <- traindat[,traindat$var$feature_types == 'ADT']$X
adt_train <- as(as.matrix(adt_train),'dgCMatrix')
gex_test <- testdat[,testdat$var$feature_types == 'GEX']$X
gex_test <- as(as.matrix(gex_test),'dgCMatrix')
adt_test <- testdat[,testdat$var$feature_types == 'ADT']$X
adt_test <- as(as.matrix(adt_test),'dgCMatrix')
# Size factor normalization already done but log1p not done
# CLR for ADT already done
gex_train <- Matrix::t(log1p(gex_train))
gex_test <- Matrix::t(log1p(gex_test))
adt_train <- Matrix::t(adt_train)
adt_test <- Matrix::t(adt_test)
# predi <- fit_predictor(gex_train,adt_train,gex_test,normalize_gex = FALSE, normalize_adt =  FALSE)
pretrained <- readRDS('model_full_neurips')
mat <- ((-sd/N) - (non_constant/(N*sd)))/(sd^2)
View(mat)
View(mat)
reference <- Js[1]
View(reference)
View(as.matrix(reference))
ref <- as.matrix(reference)
View(ref)
View(ref)
ref
ref[,1]
Js[[1]]
ref <- as.matrix(Js[[1]])
View(ref)
View(mat)
diag(sd,nrow = N)
corr <- diag(sd,nrow = N)
View(corr)
fin <- mat + diag(sd,nrow = N)
View(fin)
View(jacin)
mean(jacin[,1])
mean(jacin[1,])
sd(jacin[1,])
source("~/GitRepos_local/scLinear_R/R/sclinear.R")
fi <- feature_importance(pretrained,gex_test,normalize_gex = FALSE,n_cores = 4)
saveRDS(gexp_projected,'jacobian_input_unnormed')
saveRDS(gexp_projected,'jacobian_input_unstandardized')
jacin <- readRDS('jacobian_input_unstandardized')
ele <- jacin[1,]
N <- length(ele) #later ncol so only done once
sd <- sd(ele)
m <- mean(ele)
non_constant <- (ele - m) %*% t(ele - m)
mat <- ((-sd/N) - (non_constant/(N*sd)))/(sd^2)
fin <- mat + diag(sd,nrow = N)
View(fin)
source("~/GitRepos_local/scLinear_R/R/sclinear.R")
fi <- feature_importance(pretrained,gex_test,normalize_gex = FALSE,n_cores = 4)
fi <- feature_importance(pretrained,gex_test,normalize_gex = FALSE,n_cores = 4)
ncol(gexp_projected)
source("~/GitRepos_local/scLinear_R/R/sclinear.R")
fi <- feature_importance(pretrained,gex_test,normalize_gex = FALSE,n_cores = 4)
saveRDS(coeff_matrix,'coeff_m')
WJ <- readRDS('WJs')
v <- readRDS('v')
v<- Matrix::t(v)
cppFunction('
NumericMatrix matrix_product(NumericMatrix tm, NumericMatrix tm2) {
// Convert R matrices to Eigen matrices
const Eigen::Map<Eigen::MatrixXd> ttm(as<Eigen::Map<Eigen::MatrixXd>>(tm));
const Eigen::Map<Eigen::MatrixXd> ttm2(as<Eigen::Map<Eigen::MatrixXd>>(tm2));
// Perform matrix multiplication
Eigen::MatrixXd prod = ttm * ttm2;
// Return the result as a NumericMatrix
return wrap(prod);
}
',depends="RcppEigen")
Rcpp::cppFunction('
NumericMatrix matrix_product(NumericMatrix tm, NumericMatrix tm2) {
// Convert R matrices to Eigen matrices
const Eigen::Map<Eigen::MatrixXd> ttm(as<Eigen::Map<Eigen::MatrixXd>>(tm));
const Eigen::Map<Eigen::MatrixXd> ttm2(as<Eigen::Map<Eigen::MatrixXd>>(tm2));
// Perform matrix multiplication
Eigen::MatrixXd prod = ttm * ttm2;
// Return the result as a NumericMatrix
return wrap(prod);
}
',depends="RcppEigen")
cross_cell_average_fi_c <- function(WJ_single_model,v){
WJV <- matrix_product(t(WJ_single_model),v)
return(apply(WJV,2,mean))
}
subset <- WJ[1:1000]
subset <- abind::abind(subset,along = 3)
pbapply::pbapply(subset,1,cross_cell_average_fi_c,v)
cl <- parallel::makeCluster(4,outfile = 'mmultlog.txt')
parallel::clusterEvalQ(cl,Rcpp::cppFunction('
NumericMatrix matrix_product(NumericMatrix tm, NumericMatrix tm2) {
// Convert R matrices to Eigen matrices
const Eigen::Map<Eigen::MatrixXd> ttm(as<Eigen::Map<Eigen::MatrixXd>>(tm));
const Eigen::Map<Eigen::MatrixXd> ttm2(as<Eigen::Map<Eigen::MatrixXd>>(tm2));
// Perform matrix multiplication
Eigen::MatrixXd prod = ttm * ttm2;
// Return the result as a NumericMatrix
return wrap(prod);
}
',depends="RcppEigen")
)
parallel::clusterExport(cl,list('cross_cell_average_fi_eig'))
parallel::stopCluster()
parallel::stopCluster(cl)
cross_cell_average_fi_c <- function(WJ_single_model,v){
WJV <- matrix_product(t(WJ_single_model),v)
return(apply(WJV,2,mean))
}
cl <- parallel::makeCluster(4,outfile = 'mmultlog.txt')
parallel::clusterEvalQ(cl,Rcpp::cppFunction('
NumericMatrix matrix_product(NumericMatrix tm, NumericMatrix tm2) {
// Convert R matrices to Eigen matrices
const Eigen::Map<Eigen::MatrixXd> ttm(as<Eigen::Map<Eigen::MatrixXd>>(tm));
const Eigen::Map<Eigen::MatrixXd> ttm2(as<Eigen::Map<Eigen::MatrixXd>>(tm2));
// Perform matrix multiplication
Eigen::MatrixXd prod = ttm * ttm2;
// Return the result as a NumericMatrix
return wrap(prod);
}
',depends="RcppEigen")
)
parallel::clusterExport(cl,list('cross_cell_average_fi_c'))
pbapply::pbapply(cl=cl,subset,1,cross_cell_average_fi_eig,v)
pbapply::pbapply(cl=cl,subset,1,cross_cell_average_fi_c,v)
pbapply::pbapply(cl=cl,WJ,1,cross_cell_average_fi_c,v)
WJ <- abind(WJ,along= 3)
WJ <- abind::abind(WJ,along= 3)
parallel::stopCluster(cl)
cl <- parallel::makeCluster(4,outfile = 'mmultlog.txt')
parallel::clusterEvalQ(cl,Rcpp::cppFunction('
NumericMatrix matrix_product(NumericMatrix tm, NumericMatrix tm2) {
// Convert R matrices to Eigen matrices
const Eigen::Map<Eigen::MatrixXd> ttm(as<Eigen::Map<Eigen::MatrixXd>>(tm));
const Eigen::Map<Eigen::MatrixXd> ttm2(as<Eigen::Map<Eigen::MatrixXd>>(tm2));
// Perform matrix multiplication
Eigen::MatrixXd prod = ttm * ttm2;
// Return the result as a NumericMatrix
return wrap(prod);
}
',depends="RcppEigen")
)
parallel::clusterExport(cl,list('cross_cell_average_fi_c'))
pbapply::pbapply(cl=cl,WJ,1,cross_cell_average_fi_c,v)
parallel::stopCluster(cl)
cl <- parallel::makeCluster(2,outfile = 'mmultlog.txt')
parallel::clusterEvalQ(cl,Rcpp::cppFunction('
NumericMatrix matrix_product(NumericMatrix tm, NumericMatrix tm2) {
// Convert R matrices to Eigen matrices
const Eigen::Map<Eigen::MatrixXd> ttm(as<Eigen::Map<Eigen::MatrixXd>>(tm));
const Eigen::Map<Eigen::MatrixXd> ttm2(as<Eigen::Map<Eigen::MatrixXd>>(tm2));
// Perform matrix multiplication
Eigen::MatrixXd prod = ttm * ttm2;
// Return the result as a NumericMatrix
return wrap(prod);
}
',depends="RcppEigen")
)
parallel::clusterExport(cl,list('cross_cell_average_fi_c','v'))
pbapply::pbapply(cl=cl,WJ,1,cross_cell_average_fi_c,v)
parallel::stopCluster(cl)
pbapply::pbapply(WJ,1,cross_cell_average_fi_c,v)
pbapply::pbapply(subset,1,cross_cell_average_fi_c,v)
out <- pbapply::pbapply(subset,1,cross_cell_average_fi_c,v)
dim(out)
out <- pbapply::pbapply(subset,1,cross_cell_average_fi_c,v)
profvis::profvis(pbapply::pbapply(subset,1,cross_cell_average_fi_c,v))
profvis::profvis(
cross_cell_average_fi_c <- function(WJ_single_model,v){
WJV <- matrix_product(t(WJ_single_model),v)
return(apply(WJV,2,mean))
}
pbapply::pbapply(subset,1,cross_cell_average_fi_c,v)
profvis::profvis({
cross_cell_average_fi_c <- function(WJ_single_model,v){
WJV <- matrix_product(t(WJ_single_model),v)
return(apply(WJV,2,mean))
}
pbapply::pbapply(subset,1,cross_cell_average_fi_c,v)
})
WJ_1 <- WJ[1,,]
dim(WJ_1)
WJV <- matrix_product(t(WJ_1),v)
dim(WJ)
colMeans(WJV)
ms <- colMeans(WJV)
ms2 <- apply(WJV,2,mean)
identical(ms,ms2)
ms
which(ms != ms2)
ms[278]
ms2[278]
cross_cell_average_fi_c <- function(WJ_single_model,v){
WJV <- matrix_product(t(WJ_single_model),v)
return(colMeans(WJV))
}
profvis::profvis({
cross_cell_average_fi_c <- function(WJ_single_model,v){
WJV <- matrix_product(t(WJ_single_model),v)
return(colmeans(WJV))
}
pbapply::pbapply(subset,1,cross_cell_average_fi_c,v)
})
profvis::profvis({
cross_cell_average_fi_c <- function(WJ_single_model,v){
WJV <- matrix_product(t(WJ_single_model),v)
return(colMeans(WJV))
}
pbapply::pbapply(subset,1,cross_cell_average_fi_c,v)
})
cross_cell_average_fi_c <- function(WJ_single_model,v){
WJV <- matrix_product(t(WJ_single_model),v)
return(colMeans(WJV))
}
cl <- parallel::makeCluster(4,outfile = 'mmultlog.txt')
parallel::clusterEvalQ(cl,Rcpp::cppFunction('
NumericMatrix matrix_product(NumericMatrix tm, NumericMatrix tm2) {
// Convert R matrices to Eigen matrices
const Eigen::Map<Eigen::MatrixXd> ttm(as<Eigen::Map<Eigen::MatrixXd>>(tm));
const Eigen::Map<Eigen::MatrixXd> ttm2(as<Eigen::Map<Eigen::MatrixXd>>(tm2));
// Perform matrix multiplication
Eigen::MatrixXd prod = ttm * ttm2;
// Return the result as a NumericMatrix
return wrap(prod);
}
',depends="RcppEigen")
)
parallel::clusterExport(cl,list('cross_cell_average_fi_c','v'))
pbapply::pbapply(cl=cl,WJ,1,cross_cell_average_fi_c,v)
parallel::stopCluster(cl)
rm(WJV)
rm(WJ_1)
profvis::profvis({
cross_cell_average_fi_c <- function(WJ_single_model,v){
WJV <- matrix_product(t(WJ_single_model),v)
return(colMeans(WJV))
}
a <- pbapply::pbapply(subset,1,cross_cell_average_fi_c,v)
})
dim(out)
dim(subset)
dim(subset)[1]
profvis::profvis({
cross_cell_average_fi_c <- function(WJ_single_model,v){
WJV <- matrix_product(t(WJ_single_model),v)
return(colMeans(WJV))
}
a <- matrix(NA,nrow = ncol(v),ncol = dim(subset)[1])
a <- pbapply::pbapply(subset,1,cross_cell_average_fi_c,v)
})
a <- matrix(NA,nrow = ncol(v),ncol = dim(subset)[1])
WJ_1 <- WJ[1,,]
?pbapply
profvis::profvis({
cross_cell_average_fi_c <- function(WJ_single_model,v){
WJV <- matrix_product(t(WJ_single_model),v)
return(colMeans(WJV))
}
a <- matrix(NA,nrow = ncol(v),ncol = dim(subset)[1])
a <- apply(subset,1,cross_cell_average_fi_c,v)
})
profvis::profvis({
cross_cell_average_fi_c <- function(WJ_single_model,v){
WJV <- matrix_product(t(WJ_single_model),v)
gc()
return(colMeans(WJV))
}
a <- matrix(NA,nrow = ncol(v),ncol = dim(subset)[1])
a <- pbapply::pbapply(subset,1,cross_cell_average_fi_c,v)
})
parallel::stopCluster(cl)
cross_cell_average_fi_c <- function(WJ_single_model,v){
WJV <- matrix_product(t(WJ_single_model),v)
gc()
return(colMeans(WJV))
}
cl <- parallel::makeCluster(3,outfile = 'mmultlog.txt')
parallel::clusterEvalQ(cl,Rcpp::cppFunction('
NumericMatrix matrix_product(NumericMatrix tm, NumericMatrix tm2) {
// Convert R matrices to Eigen matrices
const Eigen::Map<Eigen::MatrixXd> ttm(as<Eigen::Map<Eigen::MatrixXd>>(tm));
const Eigen::Map<Eigen::MatrixXd> ttm2(as<Eigen::Map<Eigen::MatrixXd>>(tm2));
// Perform matrix multiplication
Eigen::MatrixXd prod = ttm * ttm2;
// Return the result as a NumericMatrix
return wrap(prod);
}
',depends="RcppEigen")
)
parallel::clusterExport(cl,list('cross_cell_average_fi_c','v'))
pbapply::pbapply(cl=cl,WJ,1,cross_cell_average_fi_c,v)
parallel::stopCluster(cl)
t(WJ_1)
rbenchmark::benchmark(t(WJ_1),Matrix::t(WJ_1))
source("~/GitRepos_local/scLinear_R/R/sclinear.R")
rm(list=ls())
reticulate::use_condaenv("C:/Users/mz24b548/AppData/Local/miniconda3/envs/scLinearDependencies")
full <- anndata::read_h5ad('GSE194122_openproblems_neurips2021_cite_BMMC_processed.h5ad/GSE194122_openproblems_neurips2021_cite_BMMC_processed.h5ad')
traindat <- full[full$obs$is_train == 'train']
testdat <- full[full$obs$is_train == 'test']
gex_train <- traindat[,traindat$var$feature_types == 'GEX']$X
gex_train <- as(as.matrix(gex_train),'dgCMatrix')
adt_train <- traindat[,traindat$var$feature_types == 'ADT']$X
adt_train <- as(as.matrix(adt_train),'dgCMatrix')
gex_test <- testdat[,testdat$var$feature_types == 'GEX']$X
gex_test <- as(as.matrix(gex_test),'dgCMatrix')
adt_test <- testdat[,testdat$var$feature_types == 'ADT']$X
adt_test <- as(as.matrix(adt_test),'dgCMatrix')
# Size factor normalization already done but log1p not done
# CLR for ADT already done
gex_train <- Matrix::t(log1p(gex_train))
gex_test <- Matrix::t(log1p(gex_test))
adt_train <- Matrix::t(adt_train)
adt_test <- Matrix::t(adt_test)
# predi <- fit_predictor(gex_train,adt_train,gex_test,normalize_gex = FALSE, normalize_adt =  FALSE)
pretrained <- readRDS('model_full_neurips')
fi <- feature_importance(pretrained,gex_test,normalize_gex = FALSE,n_cores = 4)
source("~/GitRepos_local/scLinear_R/R/sclinear.R")
fi <- feature_importance(pretrained,gex_test,normalize_gex = FALSE,n_cores = 4)
fi <- feature_importance(pretrained,gex_test,normalize_gex = FALSE,n_cores = 4)
list(...)
parallelly::serializedSize(v)
parallelly::serializedSize(v)
?parallel
class(c)
class(cl)
environment(v)
environment()
environment(v)
environment(Js)
environment(cross_cell_average_fi_c)
environment()
environment(Matrix::Matrix)
rm(list=ls())
reticulate::use_condaenv("C:/Users/mz24b548/AppData/Local/miniconda3/envs/scLinearDependencies")
full <- anndata::read_h5ad('GSE194122_openproblems_neurips2021_cite_BMMC_processed.h5ad/GSE194122_openproblems_neurips2021_cite_BMMC_processed.h5ad')
traindat <- full[full$obs$is_train == 'train']
testdat <- full[full$obs$is_train == 'test']
gex_train <- traindat[,traindat$var$feature_types == 'GEX']$X
gex_train <- as(as.matrix(gex_train),'dgCMatrix')
adt_train <- traindat[,traindat$var$feature_types == 'ADT']$X
adt_train <- as(as.matrix(adt_train),'dgCMatrix')
gex_test <- testdat[,testdat$var$feature_types == 'GEX']$X
gex_test <- as(as.matrix(gex_test),'dgCMatrix')
adt_test <- testdat[,testdat$var$feature_types == 'ADT']$X
adt_test <- as(as.matrix(adt_test),'dgCMatrix')
# Size factor normalization already done but log1p not done
# CLR for ADT already done
gex_train <- Matrix::t(log1p(gex_train))
gex_test <- Matrix::t(log1p(gex_test))
adt_train <- Matrix::t(adt_train)
adt_test <- Matrix::t(adt_test)
# predi <- fit_predictor(gex_train,adt_train,gex_test,normalize_gex = FALSE, normalize_adt =  FALSE)
pretrained <- readRDS('model_full_neurips')
